{"id":"node_modules/three/examples/jsm/shaders/FXAAShader.js","dependencies":[{"name":"/Users/elizabeth/Documents/Study/PINS/PINS Website/pins.github.io/package.json","includedInParent":true,"mtime":1734042506462},{"name":"/Users/elizabeth/Documents/Study/PINS/PINS Website/pins.github.io/node_modules/three/package.json","includedInParent":true,"mtime":1734042506371},{"name":"three","loc":{"line":3,"column":7,"index":25},"parent":"/Users/elizabeth/Documents/Study/PINS/PINS Website/pins.github.io/node_modules/three/examples/jsm/shaders/FXAAShader.js","resolved":"/Users/elizabeth/Documents/Study/PINS/PINS Website/pins.github.io/node_modules/three/build/three.module.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FXAAShader = void 0;\nvar _three = require(\"three\");\nvar FXAAShader = exports.FXAAShader = {\n  name: 'FXAAShader',\n  uniforms: {\n    'tDiffuse': {\n      value: null\n    },\n    'resolution': {\n      value: new _three.Vector2(1 / 1024, 1 / 512)\n    }\n  },\n  vertexShader: /* glsl */\"\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = uv;\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\",\n  fragmentShader: /* glsl */\"\\n\\n\\t\\t// FXAA algorithm from NVIDIA, C# implementation by Jasper Flick, GLSL port by Dave Hoskins\\n\\t\\t// http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\\n\\t\\t// https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/\\n\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tuniform vec2 resolution;\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\t#define EDGE_STEP_COUNT 6\\n\\t\\t#define EDGE_GUESS 8.0\\n\\t\\t#define EDGE_STEPS 1.0, 1.5, 2.0, 2.0, 2.0, 4.0\\n\\t\\tconst float edgeSteps[EDGE_STEP_COUNT] = float[EDGE_STEP_COUNT]( EDGE_STEPS );\\n\\n\\t\\tfloat _ContrastThreshold = 0.0312;\\n\\t\\tfloat _RelativeThreshold = 0.063;\\n\\t\\tfloat _SubpixelBlending = 1.0;\\n\\n\\t\\tvec4 Sample( sampler2D  tex2D, vec2 uv ) {\\n\\n\\t\\t\\treturn texture( tex2D, uv );\\n\\n\\t\\t}\\n\\n\\t\\tfloat SampleLuminance( sampler2D tex2D, vec2 uv ) {\\n\\n\\t\\t\\treturn dot( Sample( tex2D, uv ).rgb, vec3( 0.3, 0.59, 0.11 ) );\\n\\n\\t\\t}\\n\\n\\t\\tfloat SampleLuminance( sampler2D tex2D, vec2 texSize, vec2 uv, float uOffset, float vOffset ) {\\n\\n\\t\\t\\tuv += texSize * vec2(uOffset, vOffset);\\n\\t\\t\\treturn SampleLuminance(tex2D, uv);\\n\\n\\t\\t}\\n\\n\\t\\tstruct LuminanceData {\\n\\n\\t\\t\\tfloat m, n, e, s, w;\\n\\t\\t\\tfloat ne, nw, se, sw;\\n\\t\\t\\tfloat highest, lowest, contrast;\\n\\n\\t\\t};\\n\\n\\t\\tLuminanceData SampleLuminanceNeighborhood( sampler2D tex2D, vec2 texSize, vec2 uv ) {\\n\\n\\t\\t\\tLuminanceData l;\\n\\t\\t\\tl.m = SampleLuminance( tex2D, uv );\\n\\t\\t\\tl.n = SampleLuminance( tex2D, texSize, uv,  0.0,  1.0 );\\n\\t\\t\\tl.e = SampleLuminance( tex2D, texSize, uv,  1.0,  0.0 );\\n\\t\\t\\tl.s = SampleLuminance( tex2D, texSize, uv,  0.0, -1.0 );\\n\\t\\t\\tl.w = SampleLuminance( tex2D, texSize, uv, -1.0,  0.0 );\\n\\n\\t\\t\\tl.ne = SampleLuminance( tex2D, texSize, uv,  1.0,  1.0 );\\n\\t\\t\\tl.nw = SampleLuminance( tex2D, texSize, uv, -1.0,  1.0 );\\n\\t\\t\\tl.se = SampleLuminance( tex2D, texSize, uv,  1.0, -1.0 );\\n\\t\\t\\tl.sw = SampleLuminance( tex2D, texSize, uv, -1.0, -1.0 );\\n\\n\\t\\t\\tl.highest = max( max( max( max( l.n, l.e ), l.s ), l.w ), l.m );\\n\\t\\t\\tl.lowest = min( min( min( min( l.n, l.e ), l.s ), l.w ), l.m );\\n\\t\\t\\tl.contrast = l.highest - l.lowest;\\n\\t\\t\\treturn l;\\n\\n\\t\\t}\\n\\n\\t\\tbool ShouldSkipPixel( LuminanceData l ) {\\n\\n\\t\\t\\tfloat threshold = max( _ContrastThreshold, _RelativeThreshold * l.highest );\\n\\t\\t\\treturn l.contrast < threshold;\\n\\n\\t\\t}\\n\\n\\t\\tfloat DeterminePixelBlendFactor( LuminanceData l ) {\\n\\n\\t\\t\\tfloat f = 2.0 * ( l.n + l.e + l.s + l.w );\\n\\t\\t\\tf += l.ne + l.nw + l.se + l.sw;\\n\\t\\t\\tf *= 1.0 / 12.0;\\n\\t\\t\\tf = abs( f - l.m );\\n\\t\\t\\tf = clamp( f / l.contrast, 0.0, 1.0 );\\n\\n\\t\\t\\tfloat blendFactor = smoothstep( 0.0, 1.0, f );\\n\\t\\t\\treturn blendFactor * blendFactor * _SubpixelBlending;\\n\\n\\t\\t}\\n\\n\\t\\tstruct EdgeData {\\n\\n\\t\\t\\tbool isHorizontal;\\n\\t\\t\\tfloat pixelStep;\\n\\t\\t\\tfloat oppositeLuminance, gradient;\\n\\n\\t\\t};\\n\\n\\t\\tEdgeData DetermineEdge( vec2 texSize, LuminanceData l ) {\\n\\n\\t\\t\\tEdgeData e;\\n\\t\\t\\tfloat horizontal =\\n\\t\\t\\t\\tabs( l.n + l.s - 2.0 * l.m ) * 2.0 +\\n\\t\\t\\t\\tabs( l.ne + l.se - 2.0 * l.e ) +\\n\\t\\t\\t\\tabs( l.nw + l.sw - 2.0 * l.w );\\n\\t\\t\\tfloat vertical =\\n\\t\\t\\t\\tabs( l.e + l.w - 2.0 * l.m ) * 2.0 +\\n\\t\\t\\t\\tabs( l.ne + l.nw - 2.0 * l.n ) +\\n\\t\\t\\t\\tabs( l.se + l.sw - 2.0 * l.s );\\n\\t\\t\\te.isHorizontal = horizontal >= vertical;\\n\\n\\t\\t\\tfloat pLuminance = e.isHorizontal ? l.n : l.e;\\n\\t\\t\\tfloat nLuminance = e.isHorizontal ? l.s : l.w;\\n\\t\\t\\tfloat pGradient = abs( pLuminance - l.m );\\n\\t\\t\\tfloat nGradient = abs( nLuminance - l.m );\\n\\n\\t\\t\\te.pixelStep = e.isHorizontal ? texSize.y : texSize.x;\\n\\t\\t\\t\\n\\t\\t\\tif (pGradient < nGradient) {\\n\\n\\t\\t\\t\\te.pixelStep = -e.pixelStep;\\n\\t\\t\\t\\te.oppositeLuminance = nLuminance;\\n\\t\\t\\t\\te.gradient = nGradient;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\te.oppositeLuminance = pLuminance;\\n\\t\\t\\t\\te.gradient = pGradient;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn e;\\n\\n\\t\\t}\\n\\n\\t\\tfloat DetermineEdgeBlendFactor( sampler2D  tex2D, vec2 texSize, LuminanceData l, EdgeData e, vec2 uv ) {\\n\\n\\t\\t\\tvec2 uvEdge = uv;\\n\\t\\t\\tvec2 edgeStep;\\n\\t\\t\\tif (e.isHorizontal) {\\n\\n\\t\\t\\t\\tuvEdge.y += e.pixelStep * 0.5;\\n\\t\\t\\t\\tedgeStep = vec2( texSize.x, 0.0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tuvEdge.x += e.pixelStep * 0.5;\\n\\t\\t\\t\\tedgeStep = vec2( 0.0, texSize.y );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfloat edgeLuminance = ( l.m + e.oppositeLuminance ) * 0.5;\\n\\t\\t\\tfloat gradientThreshold = e.gradient * 0.25;\\n\\n\\t\\t\\tvec2 puv = uvEdge + edgeStep * edgeSteps[0];\\n\\t\\t\\tfloat pLuminanceDelta = SampleLuminance( tex2D, puv ) - edgeLuminance;\\n\\t\\t\\tbool pAtEnd = abs( pLuminanceDelta ) >= gradientThreshold;\\n\\n\\t\\t\\tfor ( int i = 1; i < EDGE_STEP_COUNT && !pAtEnd; i++ ) {\\n\\n\\t\\t\\t\\tpuv += edgeStep * edgeSteps[i];\\n\\t\\t\\t\\tpLuminanceDelta = SampleLuminance( tex2D, puv ) - edgeLuminance;\\n\\t\\t\\t\\tpAtEnd = abs( pLuminanceDelta ) >= gradientThreshold;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( !pAtEnd ) {\\n\\n\\t\\t\\t\\tpuv += edgeStep * EDGE_GUESS;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvec2 nuv = uvEdge - edgeStep * edgeSteps[0];\\n\\t\\t\\tfloat nLuminanceDelta = SampleLuminance( tex2D, nuv ) - edgeLuminance;\\n\\t\\t\\tbool nAtEnd = abs( nLuminanceDelta ) >= gradientThreshold;\\n\\n\\t\\t\\tfor ( int i = 1; i < EDGE_STEP_COUNT && !nAtEnd; i++ ) {\\n\\n\\t\\t\\t\\tnuv -= edgeStep * edgeSteps[i];\\n\\t\\t\\t\\tnLuminanceDelta = SampleLuminance( tex2D, nuv ) - edgeLuminance;\\n\\t\\t\\t\\tnAtEnd = abs( nLuminanceDelta ) >= gradientThreshold;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( !nAtEnd ) {\\n\\n\\t\\t\\t\\tnuv -= edgeStep * EDGE_GUESS;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfloat pDistance, nDistance;\\n\\t\\t\\tif ( e.isHorizontal ) {\\n\\n\\t\\t\\t\\tpDistance = puv.x - uv.x;\\n\\t\\t\\t\\tnDistance = uv.x - nuv.x;\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tpDistance = puv.y - uv.y;\\n\\t\\t\\t\\tnDistance = uv.y - nuv.y;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfloat shortestDistance;\\n\\t\\t\\tbool deltaSign;\\n\\t\\t\\tif ( pDistance <= nDistance ) {\\n\\n\\t\\t\\t\\tshortestDistance = pDistance;\\n\\t\\t\\t\\tdeltaSign = pLuminanceDelta >= 0.0;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tshortestDistance = nDistance;\\n\\t\\t\\t\\tdeltaSign = nLuminanceDelta >= 0.0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( deltaSign == ( l.m - edgeLuminance >= 0.0 ) ) {\\n\\n\\t\\t\\t\\treturn 0.0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0.5 - shortestDistance / ( pDistance + nDistance );\\n\\n\\t\\t}\\n\\n\\t\\tvec4 ApplyFXAA( sampler2D  tex2D, vec2 texSize, vec2 uv ) {\\n\\n\\t\\t\\tLuminanceData luminance = SampleLuminanceNeighborhood( tex2D, texSize, uv );\\n\\t\\t\\tif ( ShouldSkipPixel( luminance ) ) {\\n\\n\\t\\t\\t\\treturn Sample( tex2D, uv );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfloat pixelBlend = DeterminePixelBlendFactor( luminance );\\n\\t\\t\\tEdgeData edge = DetermineEdge( texSize, luminance );\\n\\t\\t\\tfloat edgeBlend = DetermineEdgeBlendFactor( tex2D, texSize, luminance, edge, uv );\\n\\t\\t\\tfloat finalBlend = max( pixelBlend, edgeBlend );\\n\\n\\t\\t\\tif (edge.isHorizontal) {\\n\\n\\t\\t\\t\\tuv.y += edge.pixelStep * finalBlend;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tuv.x += edge.pixelStep * finalBlend;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn Sample( tex2D, uv );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tgl_FragColor = ApplyFXAA( tDiffuse, resolution.xy, vUv );\\n\\t\\t\\t\\n\\t\\t}\"\n};"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":7,"column":0},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":1,"column":0}},{"generated":{"line":7,"column":4},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":1,"column":0},"name":"_three"},{"generated":{"line":7,"column":10},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":1,"column":0}},{"generated":{"line":7,"column":13},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":1,"column":0},"name":"require"},{"generated":{"line":7,"column":20},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":1,"column":0}},{"generated":{"line":8,"column":0},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":5,"column":0}},{"generated":{"line":8,"column":4},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":5,"column":6},"name":"FXAAShader"},{"generated":{"line":8,"column":14},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":5,"column":16}},{"generated":{"line":8,"column":17},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":5,"column":16},"name":"exports"},{"generated":{"line":8,"column":24},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":5,"column":16}},{"generated":{"line":8,"column":25},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":5,"column":16},"name":"FXAAShader"},{"generated":{"line":8,"column":35},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":5,"column":16}},{"generated":{"line":8,"column":38},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":5,"column":19}},{"generated":{"line":9,"column":2},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":7,"column":1},"name":"name"},{"generated":{"line":9,"column":6},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":7,"column":5}},{"generated":{"line":9,"column":8},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":7,"column":7}},{"generated":{"line":9,"column":20},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":7,"column":19}},{"generated":{"line":10,"column":2},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":9,"column":1},"name":"uniforms"},{"generated":{"line":10,"column":10},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":9,"column":9}},{"generated":{"line":10,"column":12},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":9,"column":11}},{"generated":{"line":11,"column":4},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":11,"column":2}},{"generated":{"line":11,"column":14},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":11,"column":12}},{"generated":{"line":11,"column":16},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":11,"column":14}},{"generated":{"line":12,"column":6},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":11,"column":16},"name":"value"},{"generated":{"line":12,"column":11},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":11,"column":21}},{"generated":{"line":12,"column":13},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":11,"column":23}},{"generated":{"line":13,"column":4},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":11,"column":28}},{"generated":{"line":13,"column":5},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":11,"column":29}},{"generated":{"line":14,"column":4},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":2}},{"generated":{"line":14,"column":16},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":14}},{"generated":{"line":14,"column":18},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":16}},{"generated":{"line":15,"column":6},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":18},"name":"value"},{"generated":{"line":15,"column":11},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":23}},{"generated":{"line":15,"column":13},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":25}},{"generated":{"line":15,"column":17},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":29},"name":"Vector2"},{"generated":{"line":15,"column":31},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":36}},{"generated":{"line":15,"column":32},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":38}},{"generated":{"line":15,"column":33},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":39}},{"generated":{"line":15,"column":36},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":42}},{"generated":{"line":15,"column":40},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":46}},{"generated":{"line":15,"column":42},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":48}},{"generated":{"line":15,"column":43},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":49}},{"generated":{"line":15,"column":46},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":52}},{"generated":{"line":15,"column":49},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":56}},{"generated":{"line":16,"column":4},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":12,"column":58}},{"generated":{"line":17,"column":2},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":14,"column":1}},{"generated":{"line":17,"column":3},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":14,"column":2}},{"generated":{"line":18,"column":2},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":16,"column":1},"name":"vertexShader"},{"generated":{"line":18,"column":14},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":16,"column":13}},{"generated":{"line":18,"column":16},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":16,"column":15}},{"generated":{"line":18,"column":183},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":25,"column":4}},{"generated":{"line":19,"column":2},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":27,"column":1},"name":"fragmentShader"},{"generated":{"line":19,"column":16},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":27,"column":15}},{"generated":{"line":19,"column":18},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":27,"column":17}},{"generated":{"line":20,"column":0},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":285,"column":0}},{"generated":{"line":20,"column":1},"source":"node_modules/three/examples/jsm/shaders/FXAAShader.js","original":{"line":285,"column":1}}],"sources":{"node_modules/three/examples/jsm/shaders/FXAAShader.js":"import {\n\tVector2\n} from 'three';\n\nconst FXAAShader = {\n\n\tname: 'FXAAShader',\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'resolution': { value: new Vector2( 1 / 1024, 1 / 512 ) }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\t// FXAA algorithm from NVIDIA, C# implementation by Jasper Flick, GLSL port by Dave Hoskins\n\t\t// http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\n\t\t// https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 resolution;\n\t\tvarying vec2 vUv;\n\n\t\t#define EDGE_STEP_COUNT 6\n\t\t#define EDGE_GUESS 8.0\n\t\t#define EDGE_STEPS 1.0, 1.5, 2.0, 2.0, 2.0, 4.0\n\t\tconst float edgeSteps[EDGE_STEP_COUNT] = float[EDGE_STEP_COUNT]( EDGE_STEPS );\n\n\t\tfloat _ContrastThreshold = 0.0312;\n\t\tfloat _RelativeThreshold = 0.063;\n\t\tfloat _SubpixelBlending = 1.0;\n\n\t\tvec4 Sample( sampler2D  tex2D, vec2 uv ) {\n\n\t\t\treturn texture( tex2D, uv );\n\n\t\t}\n\n\t\tfloat SampleLuminance( sampler2D tex2D, vec2 uv ) {\n\n\t\t\treturn dot( Sample( tex2D, uv ).rgb, vec3( 0.3, 0.59, 0.11 ) );\n\n\t\t}\n\n\t\tfloat SampleLuminance( sampler2D tex2D, vec2 texSize, vec2 uv, float uOffset, float vOffset ) {\n\n\t\t\tuv += texSize * vec2(uOffset, vOffset);\n\t\t\treturn SampleLuminance(tex2D, uv);\n\n\t\t}\n\n\t\tstruct LuminanceData {\n\n\t\t\tfloat m, n, e, s, w;\n\t\t\tfloat ne, nw, se, sw;\n\t\t\tfloat highest, lowest, contrast;\n\n\t\t};\n\n\t\tLuminanceData SampleLuminanceNeighborhood( sampler2D tex2D, vec2 texSize, vec2 uv ) {\n\n\t\t\tLuminanceData l;\n\t\t\tl.m = SampleLuminance( tex2D, uv );\n\t\t\tl.n = SampleLuminance( tex2D, texSize, uv,  0.0,  1.0 );\n\t\t\tl.e = SampleLuminance( tex2D, texSize, uv,  1.0,  0.0 );\n\t\t\tl.s = SampleLuminance( tex2D, texSize, uv,  0.0, -1.0 );\n\t\t\tl.w = SampleLuminance( tex2D, texSize, uv, -1.0,  0.0 );\n\n\t\t\tl.ne = SampleLuminance( tex2D, texSize, uv,  1.0,  1.0 );\n\t\t\tl.nw = SampleLuminance( tex2D, texSize, uv, -1.0,  1.0 );\n\t\t\tl.se = SampleLuminance( tex2D, texSize, uv,  1.0, -1.0 );\n\t\t\tl.sw = SampleLuminance( tex2D, texSize, uv, -1.0, -1.0 );\n\n\t\t\tl.highest = max( max( max( max( l.n, l.e ), l.s ), l.w ), l.m );\n\t\t\tl.lowest = min( min( min( min( l.n, l.e ), l.s ), l.w ), l.m );\n\t\t\tl.contrast = l.highest - l.lowest;\n\t\t\treturn l;\n\n\t\t}\n\n\t\tbool ShouldSkipPixel( LuminanceData l ) {\n\n\t\t\tfloat threshold = max( _ContrastThreshold, _RelativeThreshold * l.highest );\n\t\t\treturn l.contrast < threshold;\n\n\t\t}\n\n\t\tfloat DeterminePixelBlendFactor( LuminanceData l ) {\n\n\t\t\tfloat f = 2.0 * ( l.n + l.e + l.s + l.w );\n\t\t\tf += l.ne + l.nw + l.se + l.sw;\n\t\t\tf *= 1.0 / 12.0;\n\t\t\tf = abs( f - l.m );\n\t\t\tf = clamp( f / l.contrast, 0.0, 1.0 );\n\n\t\t\tfloat blendFactor = smoothstep( 0.0, 1.0, f );\n\t\t\treturn blendFactor * blendFactor * _SubpixelBlending;\n\n\t\t}\n\n\t\tstruct EdgeData {\n\n\t\t\tbool isHorizontal;\n\t\t\tfloat pixelStep;\n\t\t\tfloat oppositeLuminance, gradient;\n\n\t\t};\n\n\t\tEdgeData DetermineEdge( vec2 texSize, LuminanceData l ) {\n\n\t\t\tEdgeData e;\n\t\t\tfloat horizontal =\n\t\t\t\tabs( l.n + l.s - 2.0 * l.m ) * 2.0 +\n\t\t\t\tabs( l.ne + l.se - 2.0 * l.e ) +\n\t\t\t\tabs( l.nw + l.sw - 2.0 * l.w );\n\t\t\tfloat vertical =\n\t\t\t\tabs( l.e + l.w - 2.0 * l.m ) * 2.0 +\n\t\t\t\tabs( l.ne + l.nw - 2.0 * l.n ) +\n\t\t\t\tabs( l.se + l.sw - 2.0 * l.s );\n\t\t\te.isHorizontal = horizontal >= vertical;\n\n\t\t\tfloat pLuminance = e.isHorizontal ? l.n : l.e;\n\t\t\tfloat nLuminance = e.isHorizontal ? l.s : l.w;\n\t\t\tfloat pGradient = abs( pLuminance - l.m );\n\t\t\tfloat nGradient = abs( nLuminance - l.m );\n\n\t\t\te.pixelStep = e.isHorizontal ? texSize.y : texSize.x;\n\t\t\t\n\t\t\tif (pGradient < nGradient) {\n\n\t\t\t\te.pixelStep = -e.pixelStep;\n\t\t\t\te.oppositeLuminance = nLuminance;\n\t\t\t\te.gradient = nGradient;\n\n\t\t\t} else {\n\n\t\t\t\te.oppositeLuminance = pLuminance;\n\t\t\t\te.gradient = pGradient;\n\n\t\t\t}\n\n\t\t\treturn e;\n\n\t\t}\n\n\t\tfloat DetermineEdgeBlendFactor( sampler2D  tex2D, vec2 texSize, LuminanceData l, EdgeData e, vec2 uv ) {\n\n\t\t\tvec2 uvEdge = uv;\n\t\t\tvec2 edgeStep;\n\t\t\tif (e.isHorizontal) {\n\n\t\t\t\tuvEdge.y += e.pixelStep * 0.5;\n\t\t\t\tedgeStep = vec2( texSize.x, 0.0 );\n\n\t\t\t} else {\n\n\t\t\t\tuvEdge.x += e.pixelStep * 0.5;\n\t\t\t\tedgeStep = vec2( 0.0, texSize.y );\n\n\t\t\t}\n\n\t\t\tfloat edgeLuminance = ( l.m + e.oppositeLuminance ) * 0.5;\n\t\t\tfloat gradientThreshold = e.gradient * 0.25;\n\n\t\t\tvec2 puv = uvEdge + edgeStep * edgeSteps[0];\n\t\t\tfloat pLuminanceDelta = SampleLuminance( tex2D, puv ) - edgeLuminance;\n\t\t\tbool pAtEnd = abs( pLuminanceDelta ) >= gradientThreshold;\n\n\t\t\tfor ( int i = 1; i < EDGE_STEP_COUNT && !pAtEnd; i++ ) {\n\n\t\t\t\tpuv += edgeStep * edgeSteps[i];\n\t\t\t\tpLuminanceDelta = SampleLuminance( tex2D, puv ) - edgeLuminance;\n\t\t\t\tpAtEnd = abs( pLuminanceDelta ) >= gradientThreshold;\n\n\t\t\t}\n\n\t\t\tif ( !pAtEnd ) {\n\n\t\t\t\tpuv += edgeStep * EDGE_GUESS;\n\n\t\t\t}\n\n\t\t\tvec2 nuv = uvEdge - edgeStep * edgeSteps[0];\n\t\t\tfloat nLuminanceDelta = SampleLuminance( tex2D, nuv ) - edgeLuminance;\n\t\t\tbool nAtEnd = abs( nLuminanceDelta ) >= gradientThreshold;\n\n\t\t\tfor ( int i = 1; i < EDGE_STEP_COUNT && !nAtEnd; i++ ) {\n\n\t\t\t\tnuv -= edgeStep * edgeSteps[i];\n\t\t\t\tnLuminanceDelta = SampleLuminance( tex2D, nuv ) - edgeLuminance;\n\t\t\t\tnAtEnd = abs( nLuminanceDelta ) >= gradientThreshold;\n\n\t\t\t}\n\n\t\t\tif ( !nAtEnd ) {\n\n\t\t\t\tnuv -= edgeStep * EDGE_GUESS;\n\n\t\t\t}\n\n\t\t\tfloat pDistance, nDistance;\n\t\t\tif ( e.isHorizontal ) {\n\n\t\t\t\tpDistance = puv.x - uv.x;\n\t\t\t\tnDistance = uv.x - nuv.x;\n\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tpDistance = puv.y - uv.y;\n\t\t\t\tnDistance = uv.y - nuv.y;\n\n\t\t\t}\n\n\t\t\tfloat shortestDistance;\n\t\t\tbool deltaSign;\n\t\t\tif ( pDistance <= nDistance ) {\n\n\t\t\t\tshortestDistance = pDistance;\n\t\t\t\tdeltaSign = pLuminanceDelta >= 0.0;\n\n\t\t\t} else {\n\n\t\t\t\tshortestDistance = nDistance;\n\t\t\t\tdeltaSign = nLuminanceDelta >= 0.0;\n\n\t\t\t}\n\n\t\t\tif ( deltaSign == ( l.m - edgeLuminance >= 0.0 ) ) {\n\n\t\t\t\treturn 0.0;\n\n\t\t\t}\n\n\t\t\treturn 0.5 - shortestDistance / ( pDistance + nDistance );\n\n\t\t}\n\n\t\tvec4 ApplyFXAA( sampler2D  tex2D, vec2 texSize, vec2 uv ) {\n\n\t\t\tLuminanceData luminance = SampleLuminanceNeighborhood( tex2D, texSize, uv );\n\t\t\tif ( ShouldSkipPixel( luminance ) ) {\n\n\t\t\t\treturn Sample( tex2D, uv );\n\n\t\t\t}\n\n\t\t\tfloat pixelBlend = DeterminePixelBlendFactor( luminance );\n\t\t\tEdgeData edge = DetermineEdge( texSize, luminance );\n\t\t\tfloat edgeBlend = DetermineEdgeBlendFactor( tex2D, texSize, luminance, edge, uv );\n\t\t\tfloat finalBlend = max( pixelBlend, edgeBlend );\n\n\t\t\tif (edge.isHorizontal) {\n\n\t\t\t\tuv.y += edge.pixelStep * finalBlend;\n\n\t\t\t} else {\n\n\t\t\t\tuv.x += edge.pixelStep * finalBlend;\n\n\t\t\t}\n\n\t\t\treturn Sample( tex2D, uv );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = ApplyFXAA( tDiffuse, resolution.xy, vUv );\n\t\t\t\n\t\t}`\n\n};\n\nexport { FXAAShader };\n"},"lineCount":null}},"error":null,"hash":"d8b6cf8bf62c29eb684592cf63fd377a","cacheData":{"env":{}}}